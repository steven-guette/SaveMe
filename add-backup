#!/bin/bash

rootpath=$(dirname "$(readlink -f "$0")")/..

if [ ! -d "$rootpath/backups" ] || [ ! -d "$rootpath/packages" ]; then
    exit 1
fi

set_logs() {
    declare -n logs_list=$1
    local logs_path="$2"

    # Génération du pied de message contenant les logs.
    logs_footer_length=$((${#logs_list[0]} - 4))

    while [ "$logs_footer_length" -gt 0 ]; do
        logs_footer+="-"
        ((logs_footer_length--))
    done

    logs_list+=("\n$logs_footer\n")

    if [ "${#logs_list[@]}" -gt 0 ]; then
        for log in "${logs_list[@]}"; do
            echo -e "$log" >> "$logs_path"
        done
    fi
}

archive_name+="$current_date"

if [ -n "$archive_name" ]; then
    logs=("\n---------------------------- $archive_name ----------------------------\n")
else
    logs=("\n---------------------------- $(date +%d%m%Y-%H%M) ----------------------------\n")
fi

if [ -n "$repository_path" ] && [ -n "$archive_name" ] && [ -n "$compression" ] && [ "${#to_save}" -gt 0 ]; then
    # Création du répertoire qui servira à stocker les archives si il n'existe pas.
    if [ ! -d "$repository_path" ]; then
        mkdir -p "$repository_path"
    fi

    # Tentative d'installation de la dépendance borgbackup, en cas d'échec le script s'arrête.
    if ! command -v borg; then
        apt-get -y -qq install borgbackup

        if ! command -v borg; then
            logs+=("Impossible d'installer le paquet borgbackup, veuillez essayer une installation manuelle.")
            set_logs "logs" "$rootpath/err.log"
            exit 1
        fi
    fi

    # Gestion du fichier qui va contenir la liste des paquets à réinstaller.
    packages_path="$rootpath/packages/$(basename "$repository_path").list"

    if [ ! -f "$packages_path" ]; then
        touch "$packages_path"
        chmod 640 "$packages_path"
    fi

    dpkg --get-selections > "$packages_path"

    # Initialisation du répertoire d'archivage si c'est la première sauvegarde.
    if ! borg info "$repository_path" &> /dev/null; then
        borg init -e none "$repository_path"
    fi

    # Création d'une nouvelle archive.
    borg create -C zlib "$repository_path::$archive_name" /home /root /etc

    # Vérification de l'intégrité de l'archive.
    if ! borg check "$repository_path::$archive_name"; then
        logs+=("Les données de l'archive $archive_name sont compromises, nouvelle tentative de génération en cours.")

        # Seconde tentative si la première échoue.
        if borg delete "$repository_path::$archive_name"; then
            borg create -C zlib "$repository_path::$archive_name" /home /root /etc

            if ! borg check "$repository_path::$archive_name"; then
                logs+=("Certaines données de l'archive $archive_name sont corrompues.")
            else
                logs+=("L'archive $archive_name a été régénérée avec succès.")
            fi
        else
            logs+=("Une erreur s'est produite lors de la suppression de l'archive $archive_name.")
        fi
    else
        logs+=("L'archive $archive_name été générée avec succès.")
    fi

    # Purge des anciennes sauvegardes.
    borg prune --keep-last 5 "$repository_path"

    # Ajout de l'espace disque utilisé dans les logs.
    storage_size=$(borg info "$repository_path" | grep All)
    logs+=( "\n" \
        "Taille d'origine: $(echo "$storage_size" | awk '{print $3$4}')" \
        "Après compression: $(echo "$storage_size" | awk '{print $5$6}')" \
        "Après déduplication: $(echo "$storage_size" | awk '{print $7$8}')" \
    )

    # Purge du fichier contenant les logs au delà de 199 lignes et écriture des nouveaux logs.
    logs_file="/var/log/backup-$(basename "$repository_path").log"

    if [ -f "$logs_file" ] && [ "$(wc -l < "$logs_file")" -ge 200 ]; then
        echo > "$logs_file"
    fi

    set_logs "logs" "$logs_file"
else
    if [ -z "$repository_path" ]; then
        logs+=("Le chemin vers lequel stocker l'archives n'est pas renseigné.")
    elif [ -z "$archive_name" ]; then
        logs+=("Le nom de l'archive à générer n'est pas renseigné.")
    elif [ -z "$compression" ]; then
        logs+=("Le format de la compression à appliquer n'est pas renseigné.")
    elif [ "${#to_save}" -eq 0 ]; then
        logs+=("Aucun répertoire ou fichier n'a été sélectionné pour être sauvegardé.")
    else
        logs+=("Une erreur a été détectée dans le fichier de backup $archive_name.")
    fi

    set_logs "logs" "$rootpath/err.log"
fi